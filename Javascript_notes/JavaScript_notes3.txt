# Notes on the third JavaScript course from Code School

#
# Function expressions

Function declaration = function that is just defined and stored in memory.

Choice of functions to to build when website loads - minimise what the website has to do.

Can build functions on the fly, within code, rather than at program load time.

Function expression within code is called differently:

```
var diff = function diffOfSquares(a, b){
    return a*a - b*b;
};
```

It is only loaded into memory when this line of code is called by the programme.

As this is an assignment statement, it needs a semicolon after the last curly bracket.

To call it, call the name of the variable that the function is assigned to:

`diff(9, 5);`

But - here's the thing, because it has a variable name, you don't need the function name. You can make it an anonymous function:

```
var diff = function (a, b){
    return a*a - b*b;
};
```

If you try to print the variable the function is assigned to, i.e.:

`console.log(diff);`

It will return the code for the function.

Stored functions can be passed to other functions!

```
var greeting;
...code to set newCustomer to true or false...

if (newCustomer){ 
   greeting = function(){
     alert("Message!");
   };
} else {
  greeting = function(){
     alert("Message2!");
  };
}

closeTerminal(greeting);
function closeTerminal(message){
	 message();
}

```

#
# Using function expressions with arrays and map()

Have an array of numbers:

`var numbers = [12, 4, 3, 9, ...];`

And an array of results:

`var results = numbers.map(*some coolFunction goes in here*);`

Map always takes a function as a parameters. It applies `coolFunction` to each cell in turn.

`map()` works like a loop. It compresses the loop to one line of code.

You can also pass a function (in full) to the `map()` method:

```
var results = numbers.map(function (arrayCell){
    	      		     return arrayCell * 2;
			  }
);
```

Short functions called this way are often condensed into one line:

```
var results = numbers.map(function (arrayCell){return arrayCell * 2;});
```

#
# Returning functions and immediate invocations:

Returning a functions:

```
function mystery () {
  *some mystery code*
  return *a function expression*
}

```

A queue - add new elements to the end of it. So push().

Remove things from the queue - use shift() method. It pops things off the front and returns.

```
function function1 (par1, par2, par3){
  if(condition1){
    return function(){*function code*};
  } else {
    return function(){*alternative function code*};
  }
}
var par1 = val1;
var par2 = val2;
var par3 = val3;

var result = function1(par1, par2, par3);

result();
```

You can immediately call the function instead of storing it.

So instead of: `var result = function1(par1, par2, par3);`

You have: `result = function1(par1, par2, par3);`

But it will just return the function, but does include the correct values.

To evaluate (invoke) it immediately:

`result = function1(par1, par2, par3)();`

If you have an array of functions and want to call the ith function in it:

`var result = arrayOfFunctions[i](input pars);`

#
# Closure:

Closures used to build "function factories".

An example of a closure, is in the last course, where you are returning a function with variables that weren't created in that function. 

When we return a function from a function, where the variables were made in the external function, we have a closure. The variables are still available outside the function?

A small example:

A closure wraps up an entire environment, binding variables from ther scopes (so other functions etc).

```
function testClosure (){
  var x = 4;
  return x;
}
```

`x` is local and can only be accessed within the `textClosure` function.
Accessing `x` outside the `testClosure` will not work.

Now:

```
function testClosure (){
  var x = 4;
  function closeX() {
    return x;
  }
}
```

The inner function can access the outer function's variables, because they seem to be global variables to it.

When looking for variables, the inner function first looks inside it's own code, then outwards into the outer function. If necessary it would keep going. It then assigns the value as determined outside.

Then we assign the results of the outer function to a variable:

`var checkLocalX = testClosure();`

This returns the value, but even though the function's, scope is closed, we can still access the value.

Closures helpful in function "construction zones". They make the creation of very similar functions very efficient.

Imagine a submarine, ship and seagull. We could make a ticket maker for each of them.

```
function buildCoveTicketMaker( transport ) {
  return function ( name ) {
    alert("Here is your ticket via the " + transport + ".\n" + "Welcome to the Cold Closures Cover, " + name + "!");
  }
}
```

If we wanted ticket makers for the three things:

```
var getSubTicket = buildCoveTicketMaker("Submarine");
var getShipTicket = buildCoveTicketMaker("Ship");
var getGullTicket = buildCoveTicketMaker("Gull");
```

If you call `getSubTicket` it will look like they all have `transport`, except they have the actual values. But the named variable is still undefined. We need to call the ticket makers:

```
getSubTicket("Mario");
getShipTicket("Luigi");
getGullTicket("Bowser");
```
The functions all get called, the alert gets sorted. 

Okay, so here is how you think about it. The double function thing `buildCoveTicketMaker` is called. It returns an anonymous  function - which has one of the values (`transport`) determined, but it means that the variable it is assigned to (i.e. `getSubTicket`) is now just a call to that inner function. So, `getSubTicket` is actually just the anonymous function, with `transport` set to sub. When you call `getSubTicket` you need to call it with all the required parameters of the anonymous function (i.e.: `name`).

#
# Modifying bound values after closure:

Passenger tracker - how many times have we given a ticket to specific mode of transport.

```
function buildCoveTicketMaker( transport ) {
  var passengerNumber = 0;
  return function ( name ) {
    passengerNumber++;
    alert("Ticket using " + transport + " Welcome, " + name + "you are passenger #" + passengerNumber);
  }
}
```

This will increase the number of tickets for that mode of transportation.
Every time we call the ticket maker, it will increment the counter.

#
# More on closure:

Common mistakes:

1) Loops!

Example give a specific passenger a torpedo to look after:

```
function assignTorpedo ( name, passengerArray ){
  var torpedAssignment
  for (var i = 0; i<passengerArray.length; i++) {
    if (passengerArray[i] == name) {
      torpedoAssignment = function () {
        alert("Ahoy, " + name + " Man post at torpedo #" + (i+1) + "!");
      }
    };
  }
  return torpedoAssignment;
}

var subPassengers = ["Luke", "Leia", "Han", "Chewie", "Yoda"]
var giveAssignment = assignTorpedo("Chewie", subPassengers);
// At this point the result is the alert with "Chewie" in it.
giveAssignment();
```

The result is torpedo 5, not 4, where Chewie is in the array.

What happens is closures bind at the last opportunity. So they capture the final variable states. The loop counter gets to the end, and the value will be the last value of i, not the one where the condition was met.

To avoid this:

1) Could make the loop return immediately upon meeting the condition:

```
function assignTorpedo ( name, passengerArray ){
  var torpedAssignment
  for (var i = 0; i<passengerArray.length; i++) {
    if (passengerArray[i] == name) {
      return function () {
        alert("Ahoy, " + name + " Man post at torpedo #" + (i+1) + "!");
      };
    }
  }
  return torpedoAssignment;
}

var subPassengers = ["Luke", "Leia", "Han", "Chewie", "Yoda"]
var giveAssignment = assignTorpedo("Chewie", subPassengers);
// At this point the result is the alert with "Chewie" in it.
giveA
```

This will have the exact number at the moment of meeting condition.

Or, we could do it more like the submarine example:

```
function makeTorpedoAssigner ( passengerArray ) {
  return function ( name ) {
    for (var i = 0; i<passengerArray.length; i++) {
      if (passengerArray[i] == name {
        alert("Ahoy, " + name + " Man post at torpedo #" + (i+1) + "!");
      }
    }
  };
}

var subPassengers = ["names"];
var getTorpedoFor = makeTorpedoAssigner(subPassenger);
getTorpedoFor("Chewie");
```

So in this example, the closure only captures the name, not the index. The index is taken care of later on.

#
# Hoisting:

Load order of the function of the website. Load order is important in JavaScript, particularly when some parts of programme rely on others.

Load order is making sure each line of code can be executed when it needs to be.

When you initially open a scope, the first thing that happens is that memory will be set aside for all necassary variables and declared functions the console can see.

So initially, all the variables and functions are hoisted to the top, variables are set to undefined, until the code is run.
The functions are stored ready for use, too.

So, say you define a function twice, with the same name, both get hoisted to the top, and the second instance of the function will be the one that gets used.

Function expressions are not hoisted, they are treated as assignments. For example:

```
function getMysteryNumber () {
  var chooseMystery = function() {
    return 12;
  }

  return chooseMystery();

  var chooseMystery = function() {
    return 7;
  }
}
```

what JavaScript does is:

```
function getMysteryNumber () {
  var chooseMystery = undefined; // assignment is hoisted to the top
  var chooseMystery = undefined; // This is also hoisted, and undefined, but overwrites the previous declaration of chooseMystery.
  chooseMystery = function () {
    return 12;
  }
  return chooseMystery();
}
```

So the code never gets to the second part of getMysteryNumber() and the first one is the one that is called.

To fix hoisting, you can:

1) Move the function expressions to the top, above other executable code.
2) Make the functions outright declarations:

```
function noSeats(){
  alert("There are no seats!");
  return false;
}
```

#
# Objects:

Type of data structure. Objects contain multiple related data.

Data within the object container are called properties.

An example:

Book is an object.
Properties: title, author, publisher, numChapter, numPages, illustrator

An object is often called a composite value (it has lots of stuff in it).
properties can be numbers, strings, arrays, functions or even other objects.

An easy way is an object literal:

```
var = object1 = {property1String: val1, property2String: val2};

```

Curly brackets mean object.
You can also set properties equal to variables.

To access an object property:

`object1.property1String;`

You can change property values within an object using the dot operator.

`object1.property1String = 12;`

But if a propery was related to this, it would be wrong.

So say you had four properties:

```
var myBox = {width: 6, height: 4, length: 5, volume: 120};
```

but you change `myBox.width`, the volume would be incorrect. Instead of hardwiring it, make it:
`myBox.volume = myBox.width * myBox.height * myBox.length;`


But if there was an array:

`myBox.contents.push("blah")`

Now the external array that the object refers to is changed. It is not an independent array.

You can add properties, post creation of object.

`myBox.newProperty = 24;`

If the property isn't already present, then a new property would be added.

You can also use brackets:

`myBox["volume"]` just like Pandas data array. Indices are basically strings.
This means that you could make a property with a space in it.
But you can't access `myBox."any string"`. It has to be with a bracket method.

Brackets also accept expressions:

i.e.:

```
var myBox = {destination1: "Orlando", destination2: "Miami"};

for (var i = 1, i <= myBox["# of stops"], i++) {
  console.log(myBox["destination" + i]);
}
```
this would return "Orlando" and then "Miami" from the loop.

Deleting keywords:

`delete myBox.contents;` this just deletes the reference in the object to the external things.

If you try to delete a non-existant property, it will return true. (Because it checks if something is not there)

```
var myBox = {height: 6, length: 10, width: 12, "# of Books": 0};

function addBook (box, name, writer) {
  box["# no of Books"]++;
  box["book" + box["# of Books"]] = {title: name, author: writer};
}
```

So this adds objects, as properties under the names "book1", "book2" ...

Referencing properties of objects that are properties of other objects.

i.e.:

`console.log( myBox["book1"]["author"] )` or `console.log( myBox.book1.author )`

#
# Functionality of objects:

Example: have an aquarium object. It is filled with fish, which are each an oject:

```
var aquarium = {
  Nemo: { type: "fish", species: "clownfish", length: 3.7 },
  Dory: { type: "fish", species: "blue tang", length 6.2 },
  "Coral Castle": { type: "environment", material: "coquina", moves: false }
};
```

Maybe you want to add a fish, you can make a function to do that:

```
function addFish( container, name, type, species, length) {
  container[name] = {type: type, species: species, length: length};
}
```

or a Toy:

```
function addToy( container, name, type, material, moves) {
  container[name] = {type: type, material: material, moves: moves};
}
```

It would be better is these functions were within the object, instead of outside:

```
var aquarium = {
  Nemo: { type: "fish", species: "clownfish", length: 3.7 },
  Dory: { type: "fish", species: "blue tang", length 6.2 },
  "Coral Castle": { type: "environment", material: "coquina", moves: false },
  addFish: function (name, type, species, length) {
    this[name] = {type: type, species: species, length: length}
  }
};
```
The `this` tells the object that the function is refering to the object you are currently in.

How about deleting, adding a property after the object has been made:

```
aquarium.takeOut = function ( name ) {
  this[name].name = name;
  var temp = this[name];
  delete this[name];
  return temp;
};
```

temp is a variable to hold on to the object being remove for the time being.

So the `aquarium.takeOut` method does the removing from the `aquarium` object, but it can be saved. Although to make sure you don't lose the name of the object being removed, the `this[name].name = name;` line has added an extra property for later use.

Using a dot, rather than the bracket method, mean that the property will be just the string "name" not the parameter value for "name".

#
# Using objects:

For example how many fish are there in the tank?

An object doesn't have a length, so can't loop over the number of properties.

Enumeration -with the for-in loop.

```
var numFish = 0;
for ( key in aquarium ) {
  if ( aquarium[key].type == "fish" {
    numFish++;
  }
}
```

`key` just means property. - it's like Python loops.

But if there is no property of `type` in one of the properties, then it is `undefined`. So it still works.

Again, this can go inside the object, changing it to a function, with a return and also the reference to `aquarium` becomes `this`.

#
#
